    

#ifndef cml_stl_cmath_h__
#define cml_stl_cmath_h__

#include "TM_Global_Types.h"

#include <cmath>
#include <cstdlib>


#include <math.h>

#ifndef CML_CMATH_USE_STD_LIB
extern "C"
{
# include "TM_Base_Ext.h"
}
#endif



namespace cml
{
    
    /// Returns the absolute value of signed character value.
    /// Overloads for all variants of the abs function.
    /// It's simply calling the version from cstdlib and cmath but 
    /// in a way to avoid useless casting generated by TI libs.
    /// @param[in]       val   Constant reference to input value of type signed char  
    /// @return          Absolute value of input parameter.
    BML_INLINE static sint32 abs(const sint8& val)
    {
        return std::abs(val);
    }

    /// Returns the absolute value of signed short value.
    /// @param[in]       val   Constant reference to input value of type signed short  
    /// @return          Absolute value of input parameter.
    BML_INLINE static sint32 abs(const sint16& val)
    {
        return std::abs(val);
    }

    /// Returns the absolute value of signed integer value.
    /// @param[in]       val   Constant reference to input value of type signed int.
    /// @return          Absolute value of input parameter.
    BML_INLINE static sint32 abs(const sint32& val)
    {
        return std::abs(val);
    }

    /// Returns the absolute value of float value.
    /// @param[in]       val   Constant reference to input value of type float.
    /// @return          Absolute value of input parameter.
    BML_INLINE static float32 abs(const float32& val)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::fabsf(val);
#else
        return BML_f_Abs(val);
#endif
    }

    /// Calculates the sine with 5.2 decimals accuracy 
	/// The sine is just cosine shifted a half-pi, 
    /// so we'll adjust the argument and call the cosine approximation.
	/// @param[in]       f_angle    Input angle for which we would like to know the sine, radians
    ///                             Supported values are [-MAX_ANGLE,..,MAX_ANGLE], 
    ///                             where MAX_ANGLE =
    ///                             ([max range of uint32] * BML_f_two_Pi)-C_HALFPI
    /// @return          Sine of f_angle radians.
    BML_INLINE static float32 sin(const float32& f_angle)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::sinf(f_angle);
#else
        return GDBsin_52(f_angle);
#endif
    }
#ifndef CML_CMATH_USE_STD_LIB
	/// Calculates the sine with 3.2 decimals accuracy 
    /// This function calculates the sine with 3.2 decimals accuracy.
    /// The sine is just cosine shifted a half-pi, 
    /// so the argument is adjusted and the cosine approximation is called.
	/// @param[in]       f_angle    Input angle for which we would like to know the sine, radians
    ///                             Supported values are [-MAX_ANGLE,..,MAX_ANGLE], 
    ///                             where MAX_ANGLE =
    ///                             ([max range of uint32] * BML_f_two_Pi)-C_HALFPI
	/// @return          Sine of f_angle radians.
	BML_INLINE static float32 CML_STL_sin32(const float32& f_angle)
    {
        return GDB_sin32(f_angle);
    }	

	/// Calculates the sine with 6.6 decimals relative accuracy.
	/// Approximates the sine function using a polynomial
    /// of the 11th degree. The polynomial are the odd terms of the
    /// Taylor expansion of the exponential function.
    /// Performs bounds wrapping, but looses accuracy for very
    /// large arguments due to the reduced resolution of the argument.
    /// @param[in]       f_angle    Input angle for which we would like to know the sine, radians
    ///                             Supported values [Full range of float32]. 
    /// @return          Sine of f_angle radians.
    BML_INLINE static float32 CML_STL_sin66(const float32& f_angle)
    {
        return CML_sin66(f_angle);
    }	

	/// Calculates the sine with 6.6 decimals relative accuracy.
    /// Approximates the sine function using a polynomial
    /// of the 11th degree. The polynomial are the odd terms of the
    /// Taylor expansion of the exponential function.
    /// Valid on the interval [-pi/2..pi/2]. 
    /// Larger input range requires a range-reducing wrapper.
	/// @param[in]       f_angle    Input angle for which we would like to know the sine, radians
    ///                             Optimal range [-BML_f_Half_Pi,..,BML_f_Half_Pi]
	/// @return          Sine of f_angle radians.
	BML_INLINE static float32 CML_STL_sin66_Core(const float32& f_angle)
    {
        return CML_sin66_Core(f_angle);
    }		
#endif
    /// Calculates the cosine with 5.2 decimals accuracy 
    /// It reduces the input argument's range to [0, pi/2],  
    /// and then performs the approximation.
    /// Algorithm:
    /// cos(x)= c1 + c2*x^2 + c3*x^4 + c4*x^6
    /// which is the same as:
    /// cos(x)= c1 + x^2(c2 + c3*x^2 + c4*x^4)
    /// cos(x)= c1 + x^2(c2 + x^2(c3 + c4*x^2))
    /// @param[in]       f_angle    angle for which cosine has to be found
    ///                             Supported values are [-MAX_ANGLE,..,MAX_ANGLE], 
    ///                             where MAX_ANGLE = [max range of uint32] * BML_f_two_Pi
    /// @return          Cosine of f_angle radians.
    BML_INLINE static float32 cos(const float32& f_angle)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::cosf(f_angle);
#else
        return GDBcos_52(f_angle);
#endif
    }

#ifndef CML_CMATH_USE_STD_LIB
	/// Calculates the cosine with 3.2 decimals accuracy
	/// It reduces the input argument's range to [0, pi/2],
    /// and then performs the approximation.
    /// Algorithm:
    /// cos(x)= c1 + c2*x**2 + c3*x**4
    /// which is the same as:
    /// cos(x)= c1 + x**2(c2 + c3*x**2)
    /// @param[in]       f_angle    Input angle for which we would like to know the cosine, radians
    ///                             Supported values are [-MAX_ANGLE,..,MAX_ANGLE], 
    ///                             where MAX_ANGLE = [max range of uint32] * BML_f_two_Pi
	/// @return          Cosine of f_angle radians.
	BML_INLINE static float32 CML_STL_cos32(const float32& f_angle)
    {
        return GDB_cos32(f_angle);
    }

	/// Calculates the cosine with 6.6 decimals relative accuracy.
	/// Approximates the cosine function using a polynomial
    /// of the 11th degree. The polynomial are the odd terms of the
    /// Taylor expansion of the exponential function.
    /// Performs bounds wrapping, but looses accuracy for very
    /// large arguments due to the reduced resolution of the argument.
    /// @param[in]       f_angle    Input angle for which we would like to know the cosine, radians
    ///                             Supported values [Full range of float32]
	/// @return          Cosine of f_angle radians.
	BML_INLINE static float32 CML_STL_cos66(const float32& f_angle)
    {
        return BML_cos66(f_angle);
    }

	/// Calculates the cosine with 6.6 decimals relative accuracy.
    /// Approximates the sine function using a polynomial
    /// of the 8th degree. The polynomial are the odd terms of the
    /// Taylor expansion of the exponential function.
    /// Valid on the interval [-pi/4..pi/4]. 
    /// Larger input range requires a range-reducing wrapper.
    /// @param[in]       f_angle    Input angle for which we would like to know the cosine, radians
    ///                             Optimal range [-BML_f_Half_Pi,..,BML_f_Half_Pi]
	/// @return          Cosine of f_angle radians.
	BML_INLINE static float32 CML_STL_cos66_Core(const float32& f_angle)
    {
        return BML_cos66_Core(f_angle);
    }
#endif
    /// Computes the tangent of x with accuracy of about 5.2 decimal digits
    /// This is the main tangent approximation "driver".
    /// It reduces the input argument's range to [0, pi/4],
    /// and then calls the approximator.
    /// WARNING: We do not test for the tangent approaching
    /// infinity,  which it will at x=pi/2 and x=3*pi/2.
    /// If this is a problem in your application, take
    /// appropriate action.
    /// @param[in]       f_angle  the angle for which we want to know the tangent, radians
    ///                           Supported values are [Full range of float32]
    ///                           except ((2*n) + 1)*C_HALFPI, n is any integer.
    /// @return          Tangent of f_angle radians.
    BML_INLINE static float32 tan(const float32& f_angle)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::tanf(f_angle);
#else
        return GDBtan_52(f_angle);
#endif
    }

#ifndef CML_CMATH_USE_STD_LIB
	/// Computes the tangent of x with accuracy of about 3.2 decimal digits
	/// This is the main tangent approximation "driver". 
    /// It reduces the input argument's range to [0, pi/4], 
    /// and then calls the approximator.  
    /// WARNING: We do not test for the tangent approaching 
    /// infinity,  which it will at x=pi/2 and x=3*pi/2. 
    /// If this is a problem in your application, take appropriate action.
    /// @param[in]       f_angle  The angle for which we want to know the 
    ///                           tangent, radians
    ///                           Supported values are [Full range of float32]
    ///                           except ((2*n) + 1)*C_HALFPI, n is any integer.
	/// @return          Tangent of f_angle radians.
	BML_INLINE static float32 CML_STL_tan32(const float32& f_angle)
    {
        return GDB_tan32(f_angle);
    }	
#endif
    /// Returns the hyperbolic sine of val radians.
    /// @param[in]       f_angle    Constant reference to value representing an angle, expressed in radians. 
    ///				                One radian is equivalent to 180/PI degrees. 
    /// @return          Hyperbolic sine of f_angle radians.
    BML_INLINE static float32 sinh(const float32& f_angle)
    {
        return ::sinhf(f_angle);
    }

    /// Returns the hyperbolic cosine of val radians.
    /// @param[in]       f_angle    Constant reference to value representing an angle, expressed in radians. 
    ///				                One radian is equivalent to 180/PI degrees.
    /// @return          Hyperbolic cosine of f_angle radians.
    BML_INLINE static float32 cosh(const float32& f_angle)
    {
        return ::coshf(f_angle);
    }

    /// Returns the hyperbolic tangent of val radians.
    /// @param[in]       f_angle    Constant reference to value representing an angle, expressed in radians. 
    ///   			                One radian is equivalent to 180/PI degrees.
    /// @return          Hyperbolic tangent of f_angle radians.
    BML_INLINE static float32 tanh(const float32& f_angle)
    {
        return ::tanhf(f_angle);
    }

#ifndef CML_CMATH_USE_STD_LIB
	/// Calculates the hyperbolic tangent with 5.8 decimals 
    /// relative accuracy. Maximum relative error is 1.35e-6
	/// Approximates the hyperbolic tangent using a rational 
    /// function for arguments < 8, and by sign(arg) * 1 for 
    /// larger arguments. The method has no poles on the real axis.
    /// @param[in]       f_Arg   Input argument for which we would like to know the 
    ///                          hyperbolic tangent.
    ///                          Supported range [Full range of float32]
	/// @return          Hyperbolic tangent of f_Arg radians.
	BML_INLINE static float32 CML_STL_tanh58(const float32& f_Arg)
    {
        return CML_tanh58(f_Arg);
    }	
#endif
    /// Implements the asin() function with 6.6 decimals of accuracy
	/// This function uses the relationships between trigonomtric 
    /// and inverse trigonometric functions.
    /// tan(arccos x) = sqrt(1 - x^2) / x
    /// tan(arcsin x) = x / sqrt(1 - x^2)
    /// @param[in]       f_sin   Value for which we want the inverse sinus
    ///                          Ideal values are [-1,..,0,..,1]
	/// @return          Arcsine corresponding to the value f_sin, in radians
    BML_INLINE static float32 asin(const float32& f_sin)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::asinf(f_sin);
#else
        return GDBasin_66(f_sin);
#endif
    }

    /// Implements the acos() function with 6.6 decimals of accuracy
    /// This function uses the relationships between trigonomtric 
    /// and inverse trigonometric functions.
    /// tan(arccos x) = sqrt(1 - x^2) / x
    /// tan(arcsin x) = x / sqrt(1 - x^2)
    /// @param[in]       f_cos   Value for which we want the inverse cosinus
    ///                          Ideal values are [-1,..,0,..,1]
    /// @return          Arccosine corresponding to the value f_cos, in radians
    BML_INLINE static float32 acos(const float32& f_cos)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::acosf(f_cos);
#else
        return GDBacos_66(f_cos);
#endif
    }

#ifndef CML_CMATH_USE_STD_LIB
    /// Calculates the inverse tangent with 1.8 decimals accuracy. 
	/// Maximum error is 0.0015 radians, 0.088?
    /// Approximates the inverse tangent using a common method.
	/// @param[in]       f_x    x value of Vector (x,y) for which we want to know the atan.
    ///                         Supported range [Full range of float32]
    /// @param[in]       f_y    y value of Vector (x,y) for which we want to know the atan.
    ///                         Supported range [Full range of float32]
    /// @return          The inverse tangent of (x, y)
    BML_INLINE static float32 CML_STL_atan18(float32 f_x, float32 f_y)
    {
        return BML_atan18(f_x, f_y);
    }
#endif
	/// Computes atan(x) with about 6.6 decimal digits accuracy
	/// The input argument's range is reduced to [0, pi/12] 
    /// before the approximation takes place
    /// Algorithm: atan(x)= x(c1 + c2*x^2)/(c3 + x^2)
	/// @param[in]       f_tan   The "secant length" for which we want to know the 
    ///                          corresponding angle, radians
    ///                          Optimal values are [-MAX_ANGLE,..,MAX_ANGLE], 
    ///                          where MAX_ANGLE is square root of max value of float32
    /// @return          Arctangent of f_tan
	BML_INLINE static float32 atan(const float32& f_tan)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::atanf(f_tan);
#else
        return GDBatan_66(f_tan);
#endif
    }

    /// computes the four-quadrant atan(y/x) with about 6.6 decimal digits accuracy
    /// This function computes the four-quandrant arctangent with 
    /// about 6.6 decimal digits accuracy.
    /// The input arguments are x and y. The situation y=0 is handled correctly.
	/// @param[in]       f_xaxis   Any number 
	///                            Optimal values are [-MAX_ANGLE,..,MAX_ANGLE] 
    /// @param[in]       f_yaxis   Any number
    ///                            Optimal values are [-MAX_ANGLE,..,MAX_ANGLE], 
    ///                            where MAX_ANGLE is cube root of max value of float32
	/// @return          The four-quadrant arctangent of f_yaxis/f_xaxis in 
    ///                  radians [-Pi, Pi]
    ///                  if x=0 and y=0 the result is 0
    BML_INLINE static float32 atan2(const float32& f_xaxis, const float32& f_yaxis)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::atan2f(f_xaxis, f_yaxis);
#else
        return GDBatan2_66(f_xaxis, f_yaxis);
#endif
    }

    /// Approximates the square root of a float
	/// The relative error is bound by 4.22e-7
    /// special cases: input | output
    /// < 0 | 0
    /// DEN | 0
    /// NAN | max_float
    /// INF | max_float
    /// @param[in]       f_radicand   The radicand
    ///                               Supported range [Full positive range of float32]
    /// @return          Square root of f_radicand
    BML_INLINE static float32 sqrt(const float32& f_radicand)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::sqrtf(f_radicand);
#else
        return BML_f_Sqrt(f_radicand);
#endif
    }

#ifndef CML_CMATH_USE_STD_LIB
	/// Approximates the square root of a float
    /// The relative error is bound by 4.22e-7
    /// special cases: input | output
    /// < 0 | 0
    /// DEN | 0
    /// NAN | max_float
    /// INF | max_float
    /// @param[in]       f_radicand   The radicand
    ///                               Supported range [Full positive range of float32]
    /// @return          Square root of f_radicand
	BML_INLINE static float32 CML_STL_f_SqrtApprox(const float32& f_radicand)
    {
        return BML_f_SqrtApprox(f_radicand);
    }	

	/// Approximates the square root of x
    /// Maximum error is 6.07%. No input checks are made.
    /// The caller must guarantee that the input is valid.
	/// @param[in]       f_x   A positive real number.
	/// @return          A rough approximation of x^(1/2)
	BML_INLINE static float32 CML_STL_Sqrt_VeryFast(const float32& f_x)
    {
        return BML_Sqrt_VeryFast(f_x);
    }	

	/// Approximates the square root of x
    /// Maximum error is 2.07e-7. No input checks are made.
    /// The caller must guarantee that the input is valid.
    /// The method is described in Lomont(2003)
    /// @param[in]       f_x   A positive real number.
	/// @return          A precise calculation of x^(1/2)
	BML_INLINE static float32 CML_STL_Sqrt67(const float32& f_x)
    {
        return BML_Sqrt67(f_x);
    }		

	/// Approximates the inverse square root of x
	/// Maximum error is 3.5%. No input checks are made.
    /// The caller must guarantee that the input is valid.
    /// The method is described in Lomont(2003)
	/// @param[in]       f_x   A positive real number.
	/// @return          A rough approximation of x^(-1/2)
	BML_INLINE static float32 CML_STL_InvSqrt14(const float32& f_x)
    {
        return BML_InvSqrt14(f_x);
    }	

	/// Approximates the inverse square root of x
	/// Maximum error is 0.2%. No input checks are made.
    /// The caller must guarantee that the input is valid.
    /// The method is described in Lomont(2003)
	/// @param[in]       f_x   A positive real number.
    /// @return          A rough approximation of x^(-1/2)
	BML_INLINE static float32 CML_STL_InvSqrt27(const float32& f_x)
    {
        return BML_InvSqrt27(f_x);
    }	

	/// Approximates the inverse square root of x
	/// Maximum error is 4.8e-6. No input checks are made.
    /// The caller must guarantee that the input is valid.
    /// The method is described in Lomont(2003)
	/// @param[in]       f_x   A positive real number.
	/// @return          A highly accurate approximation of x^(-1/2)
	BML_INLINE static float32 CML_STL_InvSqrt53(const float32& f_x)
    {
        return BML_InvSqrt53(f_x);
    }	

	/// Approximates the inverse square root of x
	/// Maximum error is 2.07e-7. No input checks are made.
    /// The caller must guarantee that the input is valid.
    /// The method is described in Lomont(2003)
    /// @param[in]       f_x  A positive real number.
	/// @return          A precise calculation of x^(-1/2)
	BML_INLINE static float32 CML_STL_InvSqrt67(const float32& f_x)
    {
        return BML_InvSqrt67(f_x);
    }

	/// Fast approximation exponential function 
	/// This function does a fast approximation of the 
    /// exponential function with the help of some predetermined
    /// constant coefficients.
	/// @param[in]       f_power  Any number 
	///                           Supported values [Full range of float32]
    /// @return          Approximation of exp(f_power)
	BML_INLINE static float32 CML_STL_exp(const float32& f_power)
    {
        return GDBexp(f_power);
    }

	/// Approximates exp(x) (the natural exponential) for some number x
    /// Schraudolph (1999) adapted to 32-Bit float.
    /// Accuracy < 4% throughout the range.
	/// @param[in]       f_power   The number for which we want e^x
    /// @return          Base-e exponential value of f_power.
	BML_INLINE static float32 CML_STL_Exp_VeryFast(const float32& f_power)
    {
        return BML_Exp_VeryFast(f_power);
    }
#endif
    /// This function calculates the exponential for any number x.
    /// It adjusts the input value and calls the function GDBexp_100s in turn.
	/// @param[in]       f_power   The number for which we want e^x
    ///                            Optimal value [-MAX_VAL,..,MAX_VAL]
    ///                            where MAX_VAL is fifth root of max value of float32.
    /// @return          Base-e exponential value of f_power.
    BML_INLINE static float32 exp(const float32& f_power)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::expf(f_power);
#else
        return GDBexp_100(f_power);
#endif
    }	

    /// Returns the floating-point remainder of numerator/denominator 
    /// (rounded towards zero).
    /// fmod = numer - tquot * denom 
    /// Where tquot is the truncated (i.e., rounded towards zero) 
    /// result of numer/denom.
    /// @param[in]       numer   Constant reference to input numerator value. 
    /// @param[in]       denom   Constant reference to input denominator value. 
    /// @return          Floating-point remainder(rounded towards zero).
    BML_INLINE static float32 fmod(const float32& numer, const float32& denom)
    {
#ifdef CML_CMATH_USE_STD_LIB
        return ::fmod(numer, denom);
#else
        return numer - (static_cast<sint32>(numer/denom)*denom);
#endif
    }

#ifndef CML_CMATH_USE_STD_LIB
	/// Calculates modulus after division (similar to MATLAB)
    /// result = X - n*Y where n = floor(X/Y)
    /// returns same values as CML_Rem if X and Y have same signs
    /// @param[in]       f_value  value
    ///                  Supported values are [Full range of float32]
    ///                  Overflow may occur at higher values.
    /// @param[in]       f_modulo modulo
    ///                  Supported values are [Full range of float32]
    ///                  Overflow may occur at very small values.
	/// @return          f_value modulo f_modulo
	BML_INLINE static float32 CML_STL_f_Mod(float32 f_value, float32 f_modulo)
    {
        return BML_f_Mod(f_value, f_modulo);
    }
#endif
} // End of cml namespace

#endif // cml_stl_cmath_h__

